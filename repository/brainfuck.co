"`brainfuck compile:` compiles brainfuck code into a program object. The program can `run:` on a machine, which will instruct the machine what to do.

`brainfuck machine` interprets the instructions using a right-infinite tape of 8-bit wrapping cells, while `brainfuck luaBackend` compiles brainfuck into Lua code. You can write your own machines to interpret brainfuck programs in any way you wish or compile them to any language.

program := brainfuck compile: '+++[>+<-]'.
program run: brainfuck machine"

'switch' import.

brainfuck := 
    [tokenize: char
        switch on: char
        case: [when '+' | do [if: c c    inc]]
        case: [when '-' | do [if: c c    dec]]
        case: [when '<' | do [if: c c   left]]
        case: [when '>' | do [if: c c  right]]
        case: [when '[' | do [if: c c   loop]]
        case: [when ']' | do [if: c c    end]]
        case: [when ',' | do [if: c c  input]]
        case: [when '.' | do [if: c c output]]
        case: [when ''  | do [if: c c    end]]
        else:            [do [if: c c   noop]]
    |compile: code
        ip := Cell make: 0.
        self :=
            [read
                ip put: ip value + 1. brainfuck tokenize: (code at: ip value)
            |continue
                self read if:
                    [inc     self compose: [run: m m inc] With: self continue.
                    |dec     self compose: [run: m m dec] With: self continue.
                    |left    self compose: [run: m m left] With: self continue.
                    |right   self compose: [run: m m right] With: self continue.
                    |loop  
                             body := self continue.
                             self compose: [run: m m loop: body] With: self continue.
                    |end     [run: m]
                    |input   self compose: [run: m m input] With: self continue.
                    |output  self compose: [run: m m output] With: self continue.
                    |noop    self continue]
            |compose: a With: b
                [run: m
                    a run: m.
                    b run: m]].
        program := self compose: self continue With: [run: m m end].
    |machine
        tape := Array make.
        tape at: 1 Put: 0.
        tp := Cell make: 1.
        len := Cell make: 1.
        self := [inc    tape at: tp value Put: (tape at: tp value) + 1 % 256.
                |dec    tape at: tp value Put: (tape at: tp value) - 1 % 256.
                |left   tp put: tp value - 1.
                        tp value < 1 if: [true console error: 'Tape pointer exceeded left edge' | false].
                |right  tp put: tp value + 1.
                        tp value > len value if:
                            [true  len put: len value + 1. tape at: tp value Put: 0.
                            |false].
                |loop: body
                    (tape at: tp value) > 0 if:
                        [true  body run: self. self loop: body.
                        |false]
                |input  tp put: (console read: 1) byte.
                |output console write: (tape at: tp value) character.
                |end    tape]
    |luaBackend
        code := Cell make: 'tape, tp = {0}, 1;'.
        code := [append: piece  code put: code value, piece | ...code].
        self := [inc         code append: 'tape[tp] = (tape[tp] + 1) % 256;'
                |dec         code append: 'tape[tp] = (tape[tp] - 1) % 256;'
                |left        code append: 'tp = tp - 1;'
                |right       code append: 'tp = tp + 1;tape[tp] = tape[tp] or 0;'
                |loop: body  code append: 'while tape[tp] > 0 do '.
                             body run: self.
                             code append: ' end;'
                |input       code append: 'tape[tp] = io.read(1):byte();'
                |output      code append: 'io.write(string.char(tape[tp]));'
                |end         code value]].